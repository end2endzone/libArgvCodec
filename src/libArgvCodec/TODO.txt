DONE! - Rename project to (CommandLineEncoder & ArgumentDecoder) or (ArgumentEncoder, ArgumentDecoder, CommandLineEncoder, CommandLineDecoder)
DONE! - Move global functions of ArgumentManager.cpp out to an utility class (or util.h/cpp files)
DONE! - Change calls like c == '\\' && getSafeCharacter(cmdLine, i+1) == '\\' && getSafeCharacter(cmdLine, i+2) == '\\' && getSafeCharacter(cmdLine, i+3) == '\"'    by isSequence(cmdLine, i, "abcd")
DONE! - Rename getCommandLineArgument() to getEscapedArgument() and make it static like: static std::string getEscapedArgument(const char * iValue)
DONE! - Rename findExpectedCmdLineArguments() to getArgumentsAsSeenByCmd()
DONE! - Implement getArgumentsAsSeenByCreateProcess()
DONE! - Remove usage of ArgumentLister. Create foo.h and foo.cpp that detects from argv[0] if .exe name is "foo.exe" and outputs in foo.exe.log the list of arguments. This way, the foo module can also export functions like getArgumentsAsSeenByCmd()
DONE! - Reconsider reimplementing parseCmdLine() based on samples/rules listed within the function. Create a variable "int backSlashAccumulator" and "int doubleQuoteAccumulator" that accumulates until it sees a " character or the end of the string.
DONE! - Move code into well named classes... Create IArgumentEncoder and the following implementations: CreateProcessArgumentEncoder, CmdPromptArgumentEncoder. Also create ArgumentList class.
DONE!   IArgumentEncoder
DONE!   {
DONE!     std::string encodeArgument(const char * iValue);
DONE!     std::string encodeCommandLine(const ArgumentList & iArguments);
DONE!   }
DONE!   IArgumentDecoder
DONE!   {
DONE!     std::string decodeArgument(const char * iValue);
DONE!     ArgumentList decodeCommandLine(const char * iValue);
DONE!   }
DONE! - Make parseCmdLine(...) static and public
DONE! - Implement the following tests:
DONE!   - testCopyCtor
DONE!   - testOperatorEqual
DONE!   - testAssignmentOperator
DONE! - Extract samples of ArgumentManager::parseCmdLine() as elements of a test case
DONE! - Rename the tool to libcleanargv or libcleanarg, libargvcodec. libargvcodec WINS
DONE! - Implement case insensitive ArgumentList APIs.
DONE! - Implement automatic insertion of the = sign for "-name=value" in the following APIs: extractValue() and findValue()
DONE! - Implement automatic search for expected prefix if "name=value" not found. Search for "/", "-", and "--" expected prefixes.
DONE! - Define all functions into libargvcodec namespace
DONE! - Rename Validator::setOrphanArgumentsAccepted(bool iOrphanArgumentsAccepted); to something more meaningful like setUnknownArgumentAsError(bool)
DONE! - Rename ValidationRule::RESULT::validity to valid
DONE! - Enable all tests
DONE! - Move code which handles command line arguments validation to its own specific library. The code might be deleted later since there are already many argument validation api that already exists.
DONE! - Fix issues about warning C4251: 'libargvcodec::validation::ValidationRuleSorter::mBoolInstances' : class 'std::vector<_Ty>' needs to have dll-interface to be used by clients of class 'libargvcodec::validation::ValidationRuleSorter'
DONE! - Move code in libargvcodecvalidator under its own namespace
DONE! - Create a command line project which ask for arguments and outputs the full command line.
DONE! - Add LGPL license file.
DONE! - Create a packager project: create a zip file. Do not include References.
- Add support for validating arguments againts an argument list specification. This will allow users to specify the argument format/names/meaning and ask the manager to validate the given arguments against this specification. If will also provide a custom error message for invalid/missing arguments.
- Code cleanup: Delete libargvcodec.TODO.txt and Rules.txt
- Code cleanup: Delete libargvcodecvalidator project
- Code cleanup: Delete libargvcodectest.TestValidator.*

    std::string url, username, password;
    while(arguments.read("--login",url, username, password))
    {
…
    }
 
Arguments.read(…) should have a string prototype and an inline template for all c++ types of arguments?
 
Add support for ant property like arguments:  -Dbuild.config=test
Add support for bool ArgumentList::isHelpRequested() which looks for “/?”, or “-help” or “--help" arguments.
 
Create a Usage class with the following methods:
·         void setApplicationName(const char * iName)
·         const char * getApplicationName() const
·         void setApplicationDescription(const char * iApplicationDescription);
·         const char * getApplicationDescription() const;
·         void setOptionsPrefix(const char * iValue) //could be - / -- or NULL
·         const char * getOptionsPrefix() const
·         void addFlagOption(const char * iName, const char * iDescription); //ie: --quiet or --verbose
·         void addValueOption(const char * iName, const char * iDescription); //ie: count=5
·         //void addNameValuePairOption(const char * iPrefix, const char * iDescription); //ie: -Dbuild.config=debug -Dcolor=blue
·         void addPropertyOption(const char * iPrefix, const char * iDescription); //ie: -Dbuild.config=debug -Dcolor=blue
·         void addParameterizedOption(const char * iName, int iNumParameters, const char * iDescription) //ie: --window 0 0 640 480
·         void setParameterOptionDescription(const char * iName, int iParameterIndex, const char * iDescription);
·         void addListOption(const char * iName); //ie: --inputfiles foo.txt bar.csv […] apple.pdf
·         void show(); //output all usage and options to the console
·         std::string getUsageString() //output a multi-line string that contains all usage and options. Useful for GUI application
·         int getNumOptions() const;
·         void const OptionDescriptor * getOption(int iIndex) const;
·         struct OptionDescriptor
o   {
o   std::string name;
o   std::string description;
o   bool isMandatory;
o   bool isFlag;
o   bool isValue;
o   bool isProperty;
o   //bool isNameValuePair;
o   int numParameters;
o   bool isRepeatable;
o   }
 
bool Validator.validate(arguments, usage)





Use the apache commons cli (http://commons.apache.org/cli/) if you plan on extending that past a single arg.
"The Apache Commons CLI library provides an API for parsing command line options passed to programs. It's also able to print help messages detailing the options available for a command line tool."

Commons CLI supports different types of options:

·         POSIX like options (ie. tar -zxvf foo.tar.gz)

·         GNU like long options (ie. du --human-readable --max-depth=1)

·         Java like properties (ie. java -Djava.awt.headless=true -Djava.net.useSystemProxies=true Foo)

·         Short options with value attached (ie. gcc -O2 foo.c)

·         long options with single hyphen (ie. ant -projecthelp)